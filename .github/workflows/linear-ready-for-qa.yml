name: Add Ready for QA Label to Linear Ticket

on:
  workflow_call:
    secrets:
      LINEAR_API_KEY:
        required: true
      GITHUB_TOKEN:
        required: true

jobs:
  update-linear-ticket:
    runs-on: ubuntu-latest

    steps:
      - name: Get PR associated with commit
        id: get-pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get the head SHA from the current commit
          HEAD_SHA="${{ github.sha }}"

          # Find PRs associated with this commit
          PR_DATA=$(gh api repos/${{ github.repository }}/commits/$HEAD_SHA/pulls --jq '.[0] | {number, title, body, head_ref: .head.ref, merged: .merged}')

          if [ -z "$PR_DATA" ] || [ "$PR_DATA" == "null" ]; then
            echo "No PR found for commit $HEAD_SHA"
            echo "found=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          PR_NUMBER=$(echo "$PR_DATA" | jq -r '.number')
          PR_TITLE=$(echo "$PR_DATA" | jq -r '.title')
          PR_BODY=$(echo "$PR_DATA" | jq -r '.body')
          BRANCH_NAME=$(echo "$PR_DATA" | jq -r '.head_ref')
          PR_MERGED=$(echo "$PR_DATA" | jq -r '.merged')

          echo "Found PR #$PR_NUMBER from branch: $BRANCH_NAME"

          if [ "$PR_MERGED" != "true" ]; then
            echo "PR was not merged, skipping"
            echo "found=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "pr_title=$PR_TITLE" >> $GITHUB_OUTPUT
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "found=true" >> $GITHUB_OUTPUT

          # Store PR body in a file to handle multiline content
          echo "$PR_BODY" > /tmp/pr_body.txt

      - name: Extract Linear Ticket ID
        if: steps.get-pr.outputs.found == 'true'
        id: extract-ticket
        run: |
          BRANCH_NAME="${{ steps.get-pr.outputs.branch_name }}"
          PR_TITLE="${{ steps.get-pr.outputs.pr_title }}"
          PR_BODY=$(cat /tmp/pr_body.txt 2>/dev/null || echo "")

          # Pattern matches Linear ticket formats case-insensitively (e.g., REP-123, rep-123, Rep-123)
          TICKET_ID=$(echo "$BRANCH_NAME" | grep -oiE 'rep-[0-9]+' | head -1)

          # If not found in branch name, try PR title
          if [ -z "$TICKET_ID" ]; then
            TICKET_ID=$(echo "$PR_TITLE" | grep -oiE 'rep-[0-9]+' | head -1)
          fi

          # If not found in PR title, try PR description
          if [ -z "$TICKET_ID" ]; then
            TICKET_ID=$(echo "$PR_BODY" | grep -oiE 'rep-[0-9]+' | head -1)
          fi

          if [ -z "$TICKET_ID" ]; then
            echo "No Linear ticket ID found in branch name, PR title, or PR description"
            echo "found=false" >> $GITHUB_OUTPUT
          else
            # Convert to uppercase for Linear API
            TICKET_ID=$(echo "$TICKET_ID" | tr '[:lower:]' '[:upper:]')
            echo "Found ticket ID: $TICKET_ID"
            echo "ticket_id=$TICKET_ID" >> $GITHUB_OUTPUT
            echo "found=true" >> $GITHUB_OUTPUT
          fi

      - name: Add Ready for QA Label
        if: steps.extract-ticket.outputs.found == 'true'
        env:
          LINEAR_API_KEY: ${{ secrets.LINEAR_API_KEY }}
          TICKET_ID: ${{ steps.extract-ticket.outputs.ticket_id }}
        run: |
          # First, get the issue ID from the ticket identifier
          ISSUE_RESPONSE=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -H "Authorization: $LINEAR_API_KEY" \
            -d "{\"query\": \"query { issue(id: \\\"$TICKET_ID\\\") { id team { labels { nodes { id name } } } labels { nodes { id name } } } }\"}" \
            https://api.linear.app/graphql)

          if [ -z "$ISSUE_RESPONSE" ]; then
            echo "Linear API request failed"
            exit 1
          fi

          # Extract issue ID
          ISSUE_ID=$(echo "$ISSUE_RESPONSE" | jq -r '.data.issue.id')

          if [ "$ISSUE_ID" == "null" ] || [ -z "$ISSUE_ID" ]; then
            echo "Could not find Linear issue with ID: $TICKET_ID"
            exit 1
          fi

          echo "Found issue ID: $ISSUE_ID"

          # Check if "Ready for QA" label exists in the team
          LABEL_ID=$(echo "$ISSUE_RESPONSE" | jq -r '.data.issue.team.labels.nodes[] | select(.name == "Ready for QA") | .id')

          if [ -z "$LABEL_ID" ] || [ "$LABEL_ID" == "null" ]; then
            echo "Label 'Ready for QA' not found in team"
            exit 1
          fi

          echo "Found label ID: $LABEL_ID"

          # Get current label IDs
          CURRENT_LABELS=$(echo "$ISSUE_RESPONSE" | jq -r '[.data.issue.labels.nodes[].id] | join(",")')

          # Add new label to existing labels
          if [ -z "$CURRENT_LABELS" ]; then
            ALL_LABELS="[\"$LABEL_ID\"]"
          else
            ALL_LABELS=$(echo "$ISSUE_RESPONSE" | jq -c "[.data.issue.labels.nodes[].id] + [\"$LABEL_ID\"] | unique")
          fi

          echo "Updating issue with labels: $ALL_LABELS"

          # Build the GraphQL query with proper JSON escaping using jq
          QUERY=$(jq -n \
            --arg issueId "$ISSUE_ID" \
            --argjson labelIds "$ALL_LABELS" \
            '{query: "mutation UpdateIssue($issueId: String!, $labelIds: [String!]) { issueUpdate(id: $issueId, input: { labelIds: $labelIds }) { success issue { id identifier labels { nodes { name } } } } }", variables: {issueId: $issueId, labelIds: $labelIds}}')

          # Update the issue with the new label
          UPDATE_RESPONSE=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -H "Authorization: $LINEAR_API_KEY" \
            -d "$QUERY" \
            https://api.linear.app/graphql)

          SUCCESS=$(echo "$UPDATE_RESPONSE" | jq -r '.data.issueUpdate.success')

          if [ "$SUCCESS" == "true" ]; then
            echo "Successfully added 'Ready for QA' label to $TICKET_ID"
          else
            echo "Failed to update issue. Response: $UPDATE_RESPONSE"
            exit 1
          fi
