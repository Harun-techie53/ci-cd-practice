name: Add Ready for QA Label to Linear Ticket

on:
  workflow_call:
    secrets:
      LINEAR_API_KEY:
        required: true
      GH_TOKEN:
        required: true

jobs:
  update-linear-ticket:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Debug token
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          if [ -z "$GH_TOKEN" ]; then
            echo "ERROR: GH_TOKEN is empty!"
            exit 1
          else
            echo "GH_TOKEN is set (length: ${#GH_TOKEN} chars)"
            echo "Token prefix: ${GH_TOKEN:0:4}..."
          fi

          # Test token with curl directly
          echo "Testing token with GitHub API..."
          HTTP_CODE=$(curl -s -o /tmp/gh_response.json -w "%{http_code}" \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/user)

          echo "HTTP Status: $HTTP_CODE"
          if [ "$HTTP_CODE" != "200" ]; then
            echo "Token validation failed. Response:"
            cat /tmp/gh_response.json
            exit 1
          else
            echo "Token is valid!"
            cat /tmp/gh_response.json | jq '{login, id}'
          fi

      - name: Get PR associated with commit
        id: get-pr
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          echo "Looking for PR associated with commit: ${{ github.sha }}"

          # Method 1: Try commits/pulls endpoint (works for merge commits)
          PR_RESPONSE=$(curl -sL \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository }}/commits/${{ github.sha }}/pulls")

          PR_COUNT=$(echo "$PR_RESPONSE" | jq 'length')

          if [ "$PR_COUNT" -gt 0 ] && [ "$PR_COUNT" != "null" ]; then
            echo "Found PR via commits/pulls endpoint"
            PR_NUMBER=$(echo "$PR_RESPONSE" | jq -r '.[0].number')
            PR_TITLE=$(echo "$PR_RESPONSE" | jq -r '.[0].title')
            PR_BODY=$(echo "$PR_RESPONSE" | jq -r '.[0].body')
            BRANCH_NAME=$(echo "$PR_RESPONSE" | jq -r '.[0].head.ref')
          else
            # Method 2: For squash merges, get the most recently merged PR
            echo "Trying to find most recently merged PR..."

            PR_DATA=$(gh pr list --state merged --base main --limit 1 --json number,title,body,headRefName)

            if [ -z "$PR_DATA" ] || [ "$PR_DATA" == "[]" ]; then
              echo "No merged PR found"
              echo "found=false" >> $GITHUB_OUTPUT
              exit 0
            fi

            PR_NUMBER=$(echo "$PR_DATA" | jq -r '.[0].number')
            PR_TITLE=$(echo "$PR_DATA" | jq -r '.[0].title')
            PR_BODY=$(echo "$PR_DATA" | jq -r '.[0].body')
            BRANCH_NAME=$(echo "$PR_DATA" | jq -r '.[0].headRefName')
          fi

          if [ -z "$PR_NUMBER" ] || [ "$PR_NUMBER" == "null" ]; then
            echo "No PR found"
            echo "found=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Found PR #$PR_NUMBER"
          echo "PR Title: $PR_TITLE"
          echo "Branch: $BRANCH_NAME"

          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "pr_title=$PR_TITLE" >> $GITHUB_OUTPUT
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "found=true" >> $GITHUB_OUTPUT

          # Store PR body in a file to handle multiline content
          echo "$PR_BODY" > /tmp/pr_body.txt

      - name: Extract Linear Ticket ID
        if: steps.get-pr.outputs.found == 'true'
        id: extract-ticket
        run: |
          BRANCH_NAME="${{ steps.get-pr.outputs.branch_name }}"
          PR_TITLE="${{ steps.get-pr.outputs.pr_title }}"
          PR_BODY=$(cat /tmp/pr_body.txt 2>/dev/null || echo "")

          # Pattern matches Linear ticket formats case-insensitively (e.g., REP-123, rep-123, Rep-123)
          TICKET_ID=$(echo "$BRANCH_NAME" | grep -oiE 'pre-[0-9]+' | head -1)

          # If not found in branch name, try PR title
          if [ -z "$TICKET_ID" ]; then
            TICKET_ID=$(echo "$PR_TITLE" | grep -oiE 'pre-[0-9]+' | head -1)
          fi

          # If not found in PR title, try PR description
          if [ -z "$TICKET_ID" ]; then
            TICKET_ID=$(echo "$PR_BODY" | grep -oiE 'pre-[0-9]+' | head -1)
          fi

          if [ -z "$TICKET_ID" ]; then
            echo "No Linear ticket ID found in branch name, PR title, or PR description"
            echo "found=false" >> $GITHUB_OUTPUT
          else
            # Convert to uppercase for Linear API
            TICKET_ID=$(echo "$TICKET_ID" | tr '[:lower:]' '[:upper:]')
            echo "Found ticket ID: $TICKET_ID"
            echo "ticket_id=$TICKET_ID" >> $GITHUB_OUTPUT
            echo "found=true" >> $GITHUB_OUTPUT
          fi

      - name: Add Ready for QA Label
        if: steps.extract-ticket.outputs.found == 'true'
        env:
          LINEAR_API_KEY: ${{ secrets.LINEAR_API_KEY }}
          TICKET_ID: ${{ steps.extract-ticket.outputs.ticket_id }}
        run: |
          # First, get the issue ID from the ticket identifier
          ISSUE_RESPONSE=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -H "Authorization: $LINEAR_API_KEY" \
            -d "{\"query\": \"query { issue(id: \\\"$TICKET_ID\\\") { id team { labels { nodes { id name } } } labels { nodes { id name } } } }\"}" \
            https://api.linear.app/graphql)

          if [ -z "$ISSUE_RESPONSE" ]; then
            echo "Linear API request failed"
            exit 1
          fi

          # Extract issue ID
          ISSUE_ID=$(echo "$ISSUE_RESPONSE" | jq -r '.data.issue.id')

          if [ "$ISSUE_ID" == "null" ] || [ -z "$ISSUE_ID" ]; then
            echo "Could not find Linear issue with ID: $TICKET_ID"
            exit 1
          fi

          echo "Found issue ID: $ISSUE_ID"

          # Check if "Ready for QA" label exists in the team
          LABEL_ID=$(echo "$ISSUE_RESPONSE" | jq -r '.data.issue.team.labels.nodes[] | select(.name == "Ready for QA") | .id')

          if [ -z "$LABEL_ID" ] || [ "$LABEL_ID" == "null" ]; then
            echo "Label 'Ready for QA' not found in team"
            exit 1
          fi

          echo "Found label ID: $LABEL_ID"

          # Get current label IDs
          CURRENT_LABELS=$(echo "$ISSUE_RESPONSE" | jq -r '[.data.issue.labels.nodes[].id] | join(",")')

          # Add new label to existing labels
          if [ -z "$CURRENT_LABELS" ]; then
            ALL_LABELS="[\"$LABEL_ID\"]"
          else
            ALL_LABELS=$(echo "$ISSUE_RESPONSE" | jq -c "[.data.issue.labels.nodes[].id] + [\"$LABEL_ID\"] | unique")
          fi

          echo "Updating issue with labels: $ALL_LABELS"

          # Build the GraphQL query with proper JSON escaping using jq
          QUERY=$(jq -n \
            --arg issueId "$ISSUE_ID" \
            --argjson labelIds "$ALL_LABELS" \
            '{query: "mutation UpdateIssue($issueId: String!, $labelIds: [String!]) { issueUpdate(id: $issueId, input: { labelIds: $labelIds }) { success issue { id identifier labels { nodes { name } } } } }", variables: {issueId: $issueId, labelIds: $labelIds}}')

          # Update the issue with the new label
          UPDATE_RESPONSE=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -H "Authorization: $LINEAR_API_KEY" \
            -d "$QUERY" \
            https://api.linear.app/graphql)

          SUCCESS=$(echo "$UPDATE_RESPONSE" | jq -r '.data.issueUpdate.success')

          if [ "$SUCCESS" == "true" ]; then
            echo "Successfully added 'Ready for QA' label to $TICKET_ID"
          else
            echo "Failed to update issue. Response: $UPDATE_RESPONSE"
            exit 1
          fi

      - name: Check and Update Parent Issue
        if: steps.extract-ticket.outputs.found == 'true'
        env:
          LINEAR_API_KEY: ${{ secrets.LINEAR_API_KEY }}
          TICKET_ID: ${{ steps.extract-ticket.outputs.ticket_id }}
        run: |
          # Get the current issue with its parent and parent's children
          PARENT_RESPONSE=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -H "Authorization: $LINEAR_API_KEY" \
            -d "{\"query\": \"query { issue(id: \\\"$TICKET_ID\\\") { id parent { id identifier team { labels { nodes { id name } } } labels { nodes { id name } } children { nodes { id identifier state { name type } } } } } }\"}" \
            https://api.linear.app/graphql)

          # Check if issue has a parent
          PARENT_ID=$(echo "$PARENT_RESPONSE" | jq -r '.data.issue.parent.id')

          if [ "$PARENT_ID" == "null" ] || [ -z "$PARENT_ID" ]; then
            echo "No parent issue found for $TICKET_ID - skipping parent update"
            exit 0
          fi

          PARENT_IDENTIFIER=$(echo "$PARENT_RESPONSE" | jq -r '.data.issue.parent.identifier')
          echo "Found parent issue: $PARENT_IDENTIFIER"

          # Check if all children are in a completed state
          # Linear state types: backlog, unstarted, started, completed, canceled
          INCOMPLETE_COUNT=$(echo "$PARENT_RESPONSE" | jq '[.data.issue.parent.children.nodes[] | select(.state.type != "completed" and .state.type != "canceled")] | length')

          echo "Number of incomplete sub-issues: $INCOMPLETE_COUNT"

          if [ "$INCOMPLETE_COUNT" -gt 0 ]; then
            echo "Not all sub-issues are completed - skipping parent update"
            echo "Incomplete sub-issues:"
            echo "$PARENT_RESPONSE" | jq -r '.data.issue.parent.children.nodes[] | select(.state.type != "completed" and .state.type != "canceled") | "  - \(.identifier): \(.state.name)"'
            exit 0
          fi

          echo "All sub-issues are completed! Adding 'Ready for QA' to parent issue."

          # Check if parent already has "Ready for QA" label
          HAS_LABEL=$(echo "$PARENT_RESPONSE" | jq -r '.data.issue.parent.labels.nodes[] | select(.name == "Ready for QA") | .id')

          if [ -n "$HAS_LABEL" ] && [ "$HAS_LABEL" != "null" ]; then
            echo "Parent issue already has 'Ready for QA' label"
            exit 0
          fi

          # Get the "Ready for QA" label ID from parent's team
          LABEL_ID=$(echo "$PARENT_RESPONSE" | jq -r '.data.issue.parent.team.labels.nodes[] | select(.name == "Ready for QA") | .id')

          if [ -z "$LABEL_ID" ] || [ "$LABEL_ID" == "null" ]; then
            echo "Label 'Ready for QA' not found in parent's team"
            exit 1
          fi

          # Get current parent label IDs and add the new one
          ALL_LABELS=$(echo "$PARENT_RESPONSE" | jq -c "[.data.issue.parent.labels.nodes[].id] + [\"$LABEL_ID\"] | unique")

          echo "Updating parent issue with labels: $ALL_LABELS"

          # Update the parent issue
          QUERY=$(jq -n \
            --arg issueId "$PARENT_ID" \
            --argjson labelIds "$ALL_LABELS" \
            '{query: "mutation UpdateIssue($issueId: String!, $labelIds: [String!]) { issueUpdate(id: $issueId, input: { labelIds: $labelIds }) { success issue { id identifier labels { nodes { name } } } } }", variables: {issueId: $issueId, labelIds: $labelIds}}')

          UPDATE_RESPONSE=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -H "Authorization: $LINEAR_API_KEY" \
            -d "$QUERY" \
            https://api.linear.app/graphql)

          SUCCESS=$(echo "$UPDATE_RESPONSE" | jq -r '.data.issueUpdate.success')

          if [ "$SUCCESS" == "true" ]; then
            echo "Successfully added 'Ready for QA' label to parent issue $PARENT_IDENTIFIER"
          else
            echo "Failed to update parent issue. Response: $UPDATE_RESPONSE"
            exit 1
          fi
