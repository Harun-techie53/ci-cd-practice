name: Add Ready for QA Label to Linear Ticket

on:
  workflow_call:
    secrets:
      LINEAR_API_KEY:
        required: true
      GH_TOKEN:
        required: true

jobs:
  update-linear-ticket:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Debug token
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          if [ -z "$GH_TOKEN" ]; then
            echo "ERROR: GH_TOKEN is empty!"
            exit 1
          else
            echo "GH_TOKEN is set (length: ${#GH_TOKEN} chars)"
            echo "Token prefix: ${GH_TOKEN:0:4}..."
          fi

          # Test token with curl directly
          echo "Testing token with GitHub API..."
          HTTP_CODE=$(curl -s -o /tmp/gh_response.json -w "%{http_code}" \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/user)

          echo "HTTP Status: $HTTP_CODE"
          if [ "$HTTP_CODE" != "200" ]; then
            echo "Token validation failed. Response:"
            cat /tmp/gh_response.json
            exit 1
          else
            echo "Token is valid!"
            cat /tmp/gh_response.json | jq '{login, id}'
          fi

      - name: Get PR associated with commit
        id: get-pr
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          HEAD_SHA="${{ github.sha }}"
          echo "Looking for PR associated with commit: $HEAD_SHA"

          # Merge commits typically have format: "Merge pull request #123 from branch"
          COMMIT_MSG=$(git log -1 --pretty=%B)
          echo "Commit message: $COMMIT_MSG"

          PR_NUMBER=$(echo "$COMMIT_MSG" | grep -oE '#[0-9]+' | head -1 | tr -d '#')

          if [ -z "$PR_NUMBER" ]; then
            echo "No PR number in commit message, searching merged PRs..."
            PR_NUMBER=$(gh pr list --state merged --base main --json number,mergeCommit --jq ".[] | select(.mergeCommit.oid == \"$HEAD_SHA\") | .number" | head -1)
          fi

          if [ -z "$PR_NUMBER" ]; then
            echo "No PR found for commit $HEAD_SHA"
            echo "found=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Found PR #$PR_NUMBER"

          # Get full PR details
          PR_DATA=$(gh pr view "$PR_NUMBER" --json title,body,headRefName,state)
          PR_TITLE=$(echo "$PR_DATA" | jq -r '.title')
          PR_BODY=$(echo "$PR_DATA" | jq -r '.body')
          BRANCH_NAME=$(echo "$PR_DATA" | jq -r '.headRefName')
          PR_STATE=$(echo "$PR_DATA" | jq -r '.state')

          echo "PR Title: $PR_TITLE"
          echo "Branch: $BRANCH_NAME"
          echo "State: $PR_STATE"

          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "pr_title=$PR_TITLE" >> $GITHUB_OUTPUT
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "found=true" >> $GITHUB_OUTPUT

          # Store PR body in a file to handle multiline content
          echo "$PR_BODY" > /tmp/pr_body.txt

      - name: Extract Linear Ticket ID
        if: steps.get-pr.outputs.found == 'true'
        id: extract-ticket
        run: |
          BRANCH_NAME="${{ steps.get-pr.outputs.branch_name }}"
          PR_TITLE="${{ steps.get-pr.outputs.pr_title }}"
          PR_BODY=$(cat /tmp/pr_body.txt 2>/dev/null || echo "")

          # Pattern matches Linear ticket formats case-insensitively (e.g., REP-123, rep-123, Rep-123)
          TICKET_ID=$(echo "$BRANCH_NAME" | grep -oiE 'pre-[0-9]+' | head -1)

          # If not found in branch name, try PR title
          if [ -z "$TICKET_ID" ]; then
            TICKET_ID=$(echo "$PR_TITLE" | grep -oiE 'pre-[0-9]+' | head -1)
          fi

          # If not found in PR title, try PR description
          if [ -z "$TICKET_ID" ]; then
            TICKET_ID=$(echo "$PR_BODY" | grep -oiE 'pre-[0-9]+' | head -1)
          fi

          if [ -z "$TICKET_ID" ]; then
            echo "No Linear ticket ID found in branch name, PR title, or PR description"
            echo "found=false" >> $GITHUB_OUTPUT
          else
            # Convert to uppercase for Linear API
            TICKET_ID=$(echo "$TICKET_ID" | tr '[:lower:]' '[:upper:]')
            echo "Found ticket ID: $TICKET_ID"
            echo "ticket_id=$TICKET_ID" >> $GITHUB_OUTPUT
            echo "found=true" >> $GITHUB_OUTPUT
          fi

      - name: Add Ready for QA Label
        if: steps.extract-ticket.outputs.found == 'true'
        env:
          LINEAR_API_KEY: ${{ secrets.LINEAR_API_KEY }}
          TICKET_ID: ${{ steps.extract-ticket.outputs.ticket_id }}
        run: |
          # First, get the issue ID from the ticket identifier
          ISSUE_RESPONSE=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -H "Authorization: $LINEAR_API_KEY" \
            -d "{\"query\": \"query { issue(id: \\\"$TICKET_ID\\\") { id team { labels { nodes { id name } } } labels { nodes { id name } } } }\"}" \
            https://api.linear.app/graphql)

          if [ -z "$ISSUE_RESPONSE" ]; then
            echo "Linear API request failed"
            exit 1
          fi

          # Extract issue ID
          ISSUE_ID=$(echo "$ISSUE_RESPONSE" | jq -r '.data.issue.id')

          if [ "$ISSUE_ID" == "null" ] || [ -z "$ISSUE_ID" ]; then
            echo "Could not find Linear issue with ID: $TICKET_ID"
            exit 1
          fi

          echo "Found issue ID: $ISSUE_ID"

          # Check if "Ready for QA" label exists in the team
          LABEL_ID=$(echo "$ISSUE_RESPONSE" | jq -r '.data.issue.team.labels.nodes[] | select(.name == "Ready for QA") | .id')

          if [ -z "$LABEL_ID" ] || [ "$LABEL_ID" == "null" ]; then
            echo "Label 'Ready for QA' not found in team"
            exit 1
          fi

          echo "Found label ID: $LABEL_ID"

          # Get current label IDs
          CURRENT_LABELS=$(echo "$ISSUE_RESPONSE" | jq -r '[.data.issue.labels.nodes[].id] | join(",")')

          # Add new label to existing labels
          if [ -z "$CURRENT_LABELS" ]; then
            ALL_LABELS="[\"$LABEL_ID\"]"
          else
            ALL_LABELS=$(echo "$ISSUE_RESPONSE" | jq -c "[.data.issue.labels.nodes[].id] + [\"$LABEL_ID\"] | unique")
          fi

          echo "Updating issue with labels: $ALL_LABELS"

          # Build the GraphQL query with proper JSON escaping using jq
          QUERY=$(jq -n \
            --arg issueId "$ISSUE_ID" \
            --argjson labelIds "$ALL_LABELS" \
            '{query: "mutation UpdateIssue($issueId: String!, $labelIds: [String!]) { issueUpdate(id: $issueId, input: { labelIds: $labelIds }) { success issue { id identifier labels { nodes { name } } } } }", variables: {issueId: $issueId, labelIds: $labelIds}}')

          # Update the issue with the new label
          UPDATE_RESPONSE=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -H "Authorization: $LINEAR_API_KEY" \
            -d "$QUERY" \
            https://api.linear.app/graphql)

          SUCCESS=$(echo "$UPDATE_RESPONSE" | jq -r '.data.issueUpdate.success')

          if [ "$SUCCESS" == "true" ]; then
            echo "Successfully added 'Ready for QA' label to $TICKET_ID"
          else
            echo "Failed to update issue. Response: $UPDATE_RESPONSE"
            exit 1
          fi
